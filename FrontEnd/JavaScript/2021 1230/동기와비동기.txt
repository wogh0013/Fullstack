동기식 처리방식(Synchronize)
    - 현재 처리 방식

    call A() : A 시작 -> 일 다 끝냄 -> A 종료
    call B() : A 종료 -> B 시작 -> 일 다 끝냄 -> B 종료
    call C() : B 종료 -> C 시작 -> 일 다 끝냄 -> C 종료....

    하나의 일이 끝나야 그 다음 일이 시작이 됨.

    단점 : 만약 A를 수행하는데 걸리는 시간이 1시간이면,
           그 1시간 동안 컴퓨터가 멈춰있는 것처럼 느껴진다.
           그 시간을 기다리기 답답하다.

1. 멀티프로세싱 - A함수를 독자적인 프로그램으로 만들어서 같이 돌린다.
                 project라는 프로그램이 A를 프로그램으로 만들어서 돌린다.
                 부모프로그램과 자식프로그램이 서로 완전히 분리돼있어서 
                 부모프로그램이 자식프로그램을 통제할 수 없다.
                 그래서 잘못 작성하면 좀비프로그램이 만들어진다.
                 부모프로그램이 종료를 했는데, 자식 프로그램이 살아남아서
                 자꾸 복제를 하는 상황이 만들어진다.
                 부모프로그램과 자식프로그램 사이에 데이터도 주고 받지 못한다.
                 IPC(Inter Process Community) 프로그램이 필요, 점차 많이 안 쓰고 있다.

2. 멀티스레딩 - project를 쪼갠다. 각 쪼갠 단위를 스레드라고 한다.
               각각의 스레드는 cpu의 시간을 쪼개서 서로 왔다 갔다 하면 실행을 한다.
               타임쉐어링(시간을 쪼개서), 시스템 자원을 많이 사용한다.
               동일한 메모리 사용 시 서로 충돌 문제가 발생한다.(동기화 문제)
               자바는 7버전 이상부터 비동기를 지원한다. 그전까지는 멀티스레드 지원.

3. 비동기 - 일을 시작하고 나서 바로 끝낸다.(함수가 종료를 한다.)
            project가 A를 가동하면 A는 시스템한테 일을 시켜놓고 자기는 종료를 한다.
            그러면 시스템이 백그라운드에서 일을 하다가 일이 끝나면 신호를 보낸다.
            이러한 처리 방식을 비동기라고 하고,
            nodejs, python, kotlin 등 최신 언어들은 멀티스레드X, 비동기만 지원한다.
            (비동기 방식이 대세가 되어가고 있다.)

            project가 A를 호출하고 A는 바로 종료된다. 그리고 일이 완료되면 시스템이 우리한테 알려주는데, 
            어떤 형태나 우리가 마무리를 처리할 다른 함수를 만들어서 시스템한테 전달한다.
            그러면 시스템이 그 함수를 호출한다.

            A라는 함수와 일이 마무리되면 호출될 함수 두 개를 만들어서,
            A를 호출하면서 마무리 함수를 전달하면 시스템이 호출해준다.

            콜백함수(callback) : 사용자가 만들지만 직접 호출을 못하고, 시스템이 호출한다.
                                 시스템이 호출자라, 함수의 매개변수나 변환값을 내 마음대로 못하고 시스템이 정해준다.
                                 콜백함수를 쓰다보니 함수표현식이 필요하다. 
