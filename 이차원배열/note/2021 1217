알고리즘 시간 분석 방법 : BigO 표기법
O(1), O(n), O(n2).....

a=1;
b=2;
c=3;
...

단일 for문 -> O(n)
이중 for문 -> O(n²)

ex)
i=1;                        1
s=0;                        1
for(i=1; i<=1000; i++){     1000        n번 횟수만큼 반복
    s += i;
}
System.out.println(s);      1
---------------------------------
                            1003        n + 3 : 이 수식에서 절대적인 영향은 n에게 있음
                                        이 알고리즘의 수행시간은 O(n)
                                    
ex2) n*n + n + 200 에서는 -> n²이 가장 큰 영향이므로 O(n²)이 됨                                    

빅오 표기법
O(n³) > O(n²) > O(n) > O(lonN) > O(1)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


검색 : 배열에서 내가 원하는 데이터의 위치를 찾는 것

1. 순차검색 : O(n)
    가장 단순, 처음부터 데이터를 찾을 때까지 쭉 읽어나간다.
    만약 데이터가 100만개 있다고 했을 때, 운이 없으면 데이터가 100만 번째 있을 수도 있음.
    데이터가 n개이면 시간이 n만큼 걸린다. O(n)

2. 이분검색 : O(logN)
    데이터가 순서대로 정렬되어 있어야 한다.
    중간에 있는 데이터의 키값과, 찾고자 하는 키값을 비교
     -> 앞에 있는지, 뒤에 있는지 판단 후 한쪽을 버림
      -> 위 작업을 데이터를 찾을 때까지 절반을 버리면서 반복


3. 해쉬검색 : O(1)
    데이터를 입력하면 데이터를 해쉬함수로 통과시켜서 특정 메모리로 들어가도록 해쉬테이블로 구성해놓고
    데이터 검색을 요청하면 -> 해쉬함수를 거치면 바로 위치값을 찾는다.
    -> 이론상 한 번에 검색이 됨 (1) -> 난이도 어려움




<선형구조와 비선형구조>
선형구조 : Array, LinkedList, Stack, Queue
비선형구조 : 트리, 그래프(망)

배열을 이용한 스택과 큐 만들기
1. 스택 : 후입선출(LIFO), 나중에 들어간 데이터가 먼저 나오는 구조
       항아리 - 돌을 담으면 나중에 들어간 돌이 먼저 나온다.

함수와 관련돼서 함수를 저장하는 메모리가 스택구조이다.
main        A()     B()     C()
.
.
.   A()     B()     C()

C() 함수 호출 다음번 주소
B() 함수 호출 다음번 주소
A() 함수 호출 다음번 주소
main

1) 함수호출
2) 인터럽트 호출 - 가로채기,
3) 트리구조, 미로찾기, 로봇청소기

스택은 push() 스택에 데이터를 하나 넣는다
       pop()  스택의 맨 위에서 데이터 하나를 꺼내서 반환한다.
       isEmpty() 스택이 비면 true, 아니면 false 반환
       isFull() 스택이 꽉 차면 true, 아니면 false를 반환
       peak() 스택의 최상위 데이터를 반환

2. 큐 : 선입선출(FIFO), 먼저 들어간 데이터가 먼저 나옴.
        은행에서 줄서기
        메시지 큐, 버퍼
        데이터가 들어와서 대기하고 있다가 -> 앞에서 처리가 이루어지면 -> 하나씩 앞으로 밀려가는 구조.
        한쪽에서는 데이터가 들어오고, 한쪽에서는 데이터가 제거됨.
        1) 한 방향 큐(데큐) - 양쪽에서 입출력이 이루어진다.
        2) 우선순위 큐 - 우선순위를 따지는 큐, 비상이 걸리면 우선순위를 높여준다.
        3) 환형 큐 - 돌아가는 큐, LinkedList를 이용해 환형 큐를 만드는 게 있지만 의미 x
                     배열로 큐를 만들면

        스택 : top이 증가 -> 감소될 수 있다.
         큐  : top이 아니고, rear(데이터가 들어옴)와 front(데이터가 나감)
         └                  둘 다 front나 rear 변수가 증가이다.(감소x)


환형큐
1) 시작
    front=0
    rear=0
2) isFull
    (rear+1)%큐의 크기 == front
3) isEmpty
    rear == front
4) put()
    rear=(rear+1)%큐의 크기
    큐[rear]=데이터
5) get
    front=(front+1)%큐의 크기
    return 큐[front]























