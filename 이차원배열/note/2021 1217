알고리즘 시간 분석 방법 : BigO 표기법
O(1), O(n), O(n2).....

a=1;
b=2;
c=3;
...

단일 for문 -> O(n)
이중 for문 -> O(n²)

ex)
i=1;                        1
s=0;                        1
for(i=1; i<=1000; i++){     1000        n번 횟수만큼 반복
    s += i;
}
System.out.println(s);      1
---------------------------------
                            1003        n + 3 : 이 수식에서 절대적인 영향은 n에게 있음
                                        이 알고리즘의 수행시간은 O(n)
                                    
ex2) n*n + n + 200 에서는 -> n²이 가장 큰 영향이므로 O(n²)이 됨                                    

빅오 표기법
O(n³) > O(n²) > O(n) > O(lonN) > O(1)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


검색 : 배열에서 내가 원하는 데이터의 위치를 찾는 것

1. 순차검색 : O(n)
    가장 단순, 처음부터 데이터를 찾을 때까지 쭉 읽어나간다.
    만약 데이터가 100만개 있다고 했을 때, 운이 없으면 데이터가 100만 번째 있을 수도 있음.
    데이터가 n개이면 시간이 n만큼 걸린다. O(n)

2. 이분검색 : O(logN)
    데이터가 순서대로 정렬되어 있어야 한다.
    중간에 있는 데이터의 키값과, 찾고자 하는 키값을 비교
     -> 앞에 있는지, 뒤에 있는지 판단 후 한쪽을 버림
      -> 위 작업을 데이터를 찾을 때까지 절반을 버리면서 반복


3. 해쉬검색 : O(1)
    데이터를 입력하면 데이터를 해쉬함수로 통과시켜서 특정 메모리로 들어가도록 해쉬테이블로 구성해놓고
    데이터 검색을 요청하면 -> 해쉬함수를 거치면 바로 위치값을 찾는다.
    -> 이론상 한 번에 검색이 됨 (1) -> 난이도 어려움




<선형구조와 비선형구조>
선형구조 : Array, LinkedList, Stack, Queue
비선형구조 : 트리, 그래프(망)

배열을 이용한 스택과 큐 만들기
스택 : 후입선출(LIFO), 나중에 들어간 데이터가 먼저 나오는 구조
       항아리 - 돌을 담으면 나중에 들어간 돌이 먼저 나온다.

함수와 관련돼서 함수를 저장하는 메모리가 스택구조이다.
main        A()     B()     C()
.
.
.   A()     B()     C()

C() 함수 호출 다음번 주소
B() 함수 호출 다음번 주소
A() 함수 호출 다음번 주소
main

1) 함수호출
2) 인터럽트 호출 - 가로채기,
3) 트리구조, 미로찾기, 로봇청소기

스택은 push() 스택에 데이터를 하나 넣는다
       pop()  스택의 맨 위에서 데이터 하나를 꺼내서 반환한다.
       isEmpty() 스택이 비면 true, 아니면 false 반환
       isFull() 스택이 꽉 차면 true, 아니면 false를 반환
       peak() 스택의 최상위 데이터를 반환

























